#!/usr/local/bin/perl -w

use strict;
use Cwd;
use File::Basename;
use POSIX qw(strftime);

sub timestamp($)
{
	my ($now) = @_;
	strftime("%a %b %e %H:%M:%S %Z %Y", localtime($now));
}

sub convert($$)
{
	my ($from, $to) = @_;
	my $cmd = "convert -quality 50 -resize 192x144 $from $to";
	system($cmd);
}

sub header($)
{
	my ($debugdir) = @_;
	$debugdir = basename(getcwd());
	return <<EOM;
<html>

<head>

<title>$debugdir</title>

<style type="text/css">
<!--
body { background-color: #999; }
.block * { vertical-align: middle; }
img { margin: 1px; padding: 1px 10px 1px 10px; }
-->
</style>

</head>

<body>
EOM
}

sub templatefinder()
{
	if (-f "template.pgm") {
		my $pgmmtime = (stat("template.pgm"))[9];
		my $jpgmtime = (stat("template.jpg"))[9];
		if (!-f "template.jpg" || $pgmmtime > $jpgmtime) {
			convert("template.pgm", "template.jpg");
		}
	}

	my @output;
	foreach my $file qw(tf-scores.jpg tf-edgecounts.jpg template.jpg) {
		if (-f $file) {
			if (!@output) {
				push @output, <<EOM;

<h2>TemplateFinder</h2>

EOM
			}
			push @output, <<EOM;
<img src="$file"
	title="$file" />
EOM
		}
	}

=cut
	opendir(DIR, ".") or die "opendir $debugdir: $!\n";
	my @frames = sort grep(/^tf-\d+\.jpg$/, readdir(DIR));
	closedir(DIR) or die "closedir $debugdir: $!\n";
=cut

	@output;
}

sub templatematcher()
{
	sub histogram($)
	{
		print "\t", timestamp(time), ": histogram\n";

		my ($tmfile) = @_;
		my %freq;
		my $nframes = 0;
		open(TMFILE, $tmfile) or die "open $tmfile: $!\n";
		while (<TMFILE>) {
			my $matchcnt = $_;
			chomp $matchcnt;
			$freq{$matchcnt}++;
			$nframes++;
		}
		close(TMFILE) or die "close $tmfile: $!\n";

		my %histo;
		my @freqkeys = sort { $a <=> $b } keys %freq;
		my ($minmatch, $maxmatch) = @freqkeys[0, $#freqkeys];
		my $matchrange = $maxmatch - $minmatch;
		my $nsamples = 0;
		foreach my $matchcnt (@freqkeys) {
			my $pctile = $matchrange ? $nsamples / $nframes : 0;
			$nsamples += $freq{$matchcnt};
			$histo{$pctile} = $freq{$matchcnt} / $nframes;
		}

		\%histo;
	}

	sub gnuplot_templatematcher($$)
	{
		my ($tmfile, $histogram) = @_;

		my $tmmatchpng = $tmfile;
		$tmmatchpng =~ s#\.txt$#-match.png#;
		print "\t", timestamp(time), ": $tmmatchpng\n";
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,192
set output "$tmmatchpng"

set xtics rotate
set ylabel "Matching Pixels"

set xlabel "Frame Number"
set format x
plot "$tmfile" using 1 with points pointtype 7 pointsize 0.3
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";

		my $tmhistplot = $tmfile;
		$tmhistplot =~ s#\.txt$#-hist.plot#;
		print "\t", timestamp(time), ": $tmhistplot\n";
		my %freq;
		my $nframes = 0;
		open(TMFILE, $tmfile) or die "open $tmfile: $!\n";
		while (<TMFILE>) {
			my $matchcnt = $_;
			chomp $matchcnt;
			$freq{$matchcnt}++;
			$nframes++;
		}
		close(TMFILE) or die "close $tmfile: $!\n";

		open(PLOT, ">$tmhistplot") or die "open $tmhistplot: $!\n";
		foreach my $matchcnt (keys %freq) {
			printf PLOT "%6u %12.6f\n",
			       $matchcnt, $freq{$matchcnt} / $nframes;
		}
		close(PLOT) or die "close $tmhistplot: $!\n";

		my $tmhistpng = $tmfile;
		$tmhistpng =~ s#\.txt$#-hist.png#;
		print "\t", timestamp(time), ": $tmhistpng\n";
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,192
set output "$tmhistpng"

set xtics rotate
set ylabel "Fraction of Frames"

set xlabel "Template Edge Pixels Matched"
set format x
plot "$tmhistplot" using 1:2 with points pointtype 7 pointsize 0.5
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";
		unlink $tmhistplot;

		return ($tmmatchpng, $tmhistpng);
	}

	my $tmfile = "";
	foreach my $testfile qw(TemplateMatcher-pgm.txt
			TemplateMatcher-yuv.txt) {
		if (-f $testfile) {
			$tmfile = $testfile;
			last;
		}
	}
	return "" if !$tmfile;

	my $histo = histogram($tmfile);
	my @tmgraphs = gnuplot_templatematcher($tmfile, $histo);
	my @output;
	if (@tmgraphs) {
		push @output, <<EOM;

<h2>TemplateMatcher</h2>

EOM

		my $first = 1;
		foreach my $tmgraph (@tmgraphs) {
			if (-f $tmgraph) {
				if (!$first) {
					push @output, <<EOM;
<br />
EOM
				}
				push @output, <<EOM;
<img src="$tmgraph"
	title="$tmgraph" />
EOM
				$first = 0;
			}
		}
	}
	@output;
}

sub histogramanalyzer()
{
	sub gnuplot_histogramanalyzer($)
	{
		my ($hafile) = @_;

		my $halineno = 0;

		my $columnsplot = $hafile;
		$columnsplot =~ s#\.txt$#-columns.plot#;
		open(HAFILE, $hafile) or die "open $hafile: $!\n";
		print "\t", timestamp(time), ": $columnsplot\n";
		open(PLOT, ">$columnsplot") or die "open $columnsplot: $!\n";
		$halineno = 0;
		while (<HAFILE>) {
			my ($mincol, $width) = (split)[6,4];
			my $maxcol = $mincol + $width;
			my $midcol = ($mincol + $maxcol) / 2;
			print PLOT "$halineno\t$midcol\t$mincol\t$maxcol\n";
			$halineno++;
		}
		close(PLOT) or die "close $columnsplot: $!\n";
		close(HAFILE) or die "close $hafile: $!\n";

		my $columnspng = $hafile;
		$columnspng =~ s#\.txt$#-columns.png#;
		print "\t", timestamp(time), ": $columnspng\n";
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,192
set output "$columnspng"

set xtics rotate
set ylabel "Border Min/Max Column"

set xlabel "Frame Number"
set format x
set bars 0
plot "$columnsplot" with yerrorbars
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";
		unlink $columnsplot;

		my $rowsplot = $hafile;
		$rowsplot =~ s#\.txt$#-rows.plot#;
		open(HAFILE, $hafile) or die "open $hafile: $!\n";
		print "\t", timestamp(time), ": $rowsplot\n";
		open(PLOT, ">$rowsplot") or die "open $rowsplot: $!\n";
		$halineno = 0;
		while (<HAFILE>) {
			my ($minrow, $height) = (split)[7,5];
			my $maxrow = $minrow + $height;
			my $midrow = ($minrow + $maxrow) / 2;
			print PLOT "$halineno\t$midrow\t$minrow\t$maxrow\n";
			$halineno++;
		}
		close(PLOT) or die "close $rowsplot: $!\n";
		close(HAFILE) or die "close $hafile: $!\n";

		my $rowspng = $hafile;
		$rowspng =~ s#\.txt$#-rows.png#;
		print "\t", timestamp(time), ": $rowspng\n";
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,192
set output "$rowspng"

set xtics rotate
set ylabel "Border Min/Max Row"

set xlabel "Frame Number"
set format x
set bars 0
plot "$rowsplot" with yerrorbars
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";
		unlink $rowsplot;

		my $blankpng = $hafile;
		$blankpng =~ s#\.txt$#-blanks.png#;
		print "\t", timestamp(time), ": $blankpng\n";
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,192
set output "$blankpng"

set xtics rotate
set ylabel "Blank"

set xlabel "Frame Number"
set format x
plot "$hafile" using 1 with points pointtype 7 pointsize 0.3
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";

		my $greypng = $hafile;
		$greypng =~ s#\.txt$#-greylevels.png#;
		print "\t", timestamp(time), ": $greypng\n";
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,192
set output "$greypng"

set xtics rotate
set ylabel "Median Grey Level"
set yrange [0:225]

set xlabel "Frame Number"
set format x
plot "$hafile" using 3 with points pointtype 7 pointsize 0.3
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";

		return ($columnspng, $rowspng, $blankpng, $greypng);
	}

	my $hafile = "";
	foreach my $testfile qw(HistogramAnalyzer-pgm.txt
			HistogramAnalyzer-yuv.txt) {
		if (-f $testfile) {
			$hafile = $testfile;
			last;
		}
	}
	return "" if !$hafile;

	my @histographs = gnuplot_histogramanalyzer($hafile);
	my @output;
	if (@histographs) {
		push @output, <<EOM;

<h2>HistogramAnalyzer</h2>

EOM
		my $first = 1;
		foreach my $histograph (@histographs) {
			if (-f $histograph) {
				if (!$first) {
					push @output, <<EOM;
<br />
EOM
				}
				push @output, <<EOM;
<img src="$histograph"
	title="$histograph" />
EOM
				$first = 0;
			}
		}
	}
	@output;
}

sub footer()
{
	return <<EOM;

</body>

</html>
EOM
}

sub analyze($)
{
	my ($debugdir) = @_;

	chdir($debugdir) or die "chdir $debugdir: $!\n";
	my @output;
	push @output, header($debugdir);
	push @output, templatefinder();
	push @output, templatematcher();
	push @output, histogramanalyzer();
	push @output, footer();

	my $output = "index.html";
	open(OUTPUT, ">$output") or die "open $output: $!\n";
	print OUTPUT @output or die "print $output: $!\n";
	close(OUTPUT) or die "close $output: $!\n";
}

if (!@ARGV) {
	my $basename = basename($0);
	print <<EOM;
Usage: $0 <debugdir> [debugdir...]
Generates an index.html file with graphical report on mythcommflag analysis
Requires ImageMagick and Gnuplot

Example: $basename /media/myth/recordedtv/1051_20061214210000-debug
EOM
}

umask(022);
my $cwd = getcwd();
foreach my $debugdir (@ARGV) {
	print timestamp(time), ": $debugdir\n";
	analyze($debugdir);
	chdir($cwd) or die "chdir $cwd: $!\n";
}
