#!/usr/local/bin/perl -w

use strict;
use Cwd;
use File::Basename;

sub convert($$)
{
	my ($from, $to) = @_;
	my $cmd = "convert -quality 50 -resize 192x144 $from $to";
	system($cmd);
}

sub header($)
{
	my ($debugdir) = @_;
	$debugdir = basename(getcwd());
	return <<EOM;
<html>

<head>

<title>$debugdir</title>

<style type="text/css">
<!--
body { background-color: #999; }
.block * { vertical-align: middle; }
img { margin: 1px; padding: 1px 10px 1px 10px; }
-->
</style>

</head>

<body>
EOM
}

sub templatefinder()
{
	if (-f "template.pgm") {
		my $pgmmtime = (stat("template.pgm"))[9];
		my $jpgmtime = (stat("template.jpg"))[9];
		if (!-f "template.jpg" || $pgmmtime > $jpgmtime) {
			convert("template.pgm", "template.jpg");
		}
	}

	my @output;
	foreach my $file qw(tf-scores.jpg tf-edgecounts.jpg template.jpg) {
		if (-f $file) {
			if (!@output) {
				push @output, <<EOM;

<h2>TemplateFinder</h2>

EOM
			}
			push @output, <<EOM;
<img src="$file"
	title="$file" />
EOM
		}
	}

=cut
	opendir(DIR, ".") or die "opendir $debugdir: $!\n";
	my @frames = sort grep(/^tf-\d+\.jpg$/, readdir(DIR));
	closedir(DIR) or die "closedir $debugdir: $!\n";
=cut

	@output;
}

sub templatematcher()
{
	sub histogram($)
	{
		my ($tmfile) = @_;
		my %freq;
		my $nframes = 0;
		open(TMFILE, $tmfile) or die "open $tmfile: $!\n";
		while (<TMFILE>) {
			my $matchcnt = $_;
			chomp $matchcnt;
			$freq{$matchcnt}++;
			$nframes++;
		}
		close(TMFILE) or die "close $tmfile: $!\n";

		my %histo;
		my @freqkeys = sort { $a <=> $b } keys %freq;
		my ($minmatch, $maxmatch) = @freqkeys[0, $#freqkeys];
		my $matchrange = $maxmatch - $minmatch;
		foreach my $matchcnt (@freqkeys) {
			my $pctile = $matchrange ?
				($matchcnt - $minmatch) / $matchrange :
				0;
			$histo{$pctile} = $freq{$matchcnt} / $nframes;
		}

		\%histo;
	}

	sub gnuplot_templatematcher($$)
	{
		my ($tmfile, $histogram) = @_;

		my $tmplot = $tmfile;
		$tmplot =~ s#\.txt$#.plot#;
		open(PLOT, ">$tmplot") or die "open $tmplot: $!\n";
		foreach my $matchcnt (sort { $a <=> $b } keys %$histogram) {
			printf PLOT "%12.6f %12.6f\n",
				$matchcnt, $histogram->{$matchcnt};
		}
		close(PLOT) or die "close $tmplot: $!\n";

		my $tmpng = $tmfile;
		$tmpng =~ s#\.txt$#.png#;
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,256
set output "$tmpng"

set xtics rotate
set ylabel "Fraction of Frames"

set xlabel "Percentile of Template Edge Pixels Matched"
set format x
plot "$tmplot" using 1:2 with points pointtype 7 pointsize 0.5
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";
		unlink $tmplot;

		return $tmpng;
	}

	my $tmfile = "";
	foreach my $testfile qw(TemplateMatcher-pgm.txt
			TemplateMatcher-yuv.txt) {
		if (-f $testfile) {
			$tmfile = $testfile;
			last;
		}
	}
	return "" if !$tmfile;

	my $tmgraphic = gnuplot_templatematcher($tmfile, histogram($tmfile));
	my @output;
	if (-f $tmgraphic) {
		push @output, <<EOM;

<h2>TemplateMatcher</h2>

<img src="$tmgraphic"
	title="$tmgraphic" />
EOM
	}
	@output;
}

sub histogramanalyzer()
{
	sub gnuplot_histogramanalyzer($)
	{
		my ($hafile) = @_;

		my $halineno = 0;

		my $blankpng = $hafile;
		$blankpng =~ s#\.txt$#-blanks.png#;
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,256
set output "$blankpng"

set xtics rotate
set ylabel "Blank"

set xlabel "Frame Number"
set format x
plot "$hafile" using 1 with points pointtype 7 pointsize 0.3
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";

		my $greypng = $hafile;
		$greypng =~ s#\.txt$#-greylevels.png#;
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,256
set output "$greypng"

set xtics rotate
set ylabel "Median Grey Level"
set yrange [0:225]

set xlabel "Frame Number"
set format x
plot "$hafile" using 3 with points pointtype 7 pointsize 0.3
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";

		my $columnsplot = $hafile;
		$columnsplot =~ s#\.txt$#-columns.plot#;
		open(HAFILE, $hafile) or die "open $hafile: $!\n";
		open(PLOT, ">$columnsplot") or die "open $columnsplot: $!\n";
		$halineno = 0;
		while (<HAFILE>) {
			my ($min, $width) = (split)[6,4];
			my $max = $min + $width;
			my $mid = ($min + $max) / 2;
			my $delta = $mid - $min;
			print PLOT "$halineno\t$mid\t$delta\n";
			$halineno++;
		}
		close(PLOT) or die "close $columnsplot: $!\n";
		close(HAFILE) or die "close $hafile: $!\n";

		my $columnspng = $hafile;
		$columnspng =~ s#\.txt$#-columns.png#;
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,256
set output "$columnspng"

set xtics rotate
set ylabel "Border Min/Max Column"

set xlabel "Frame Number"
set format x
plot "$columnsplot" with yerrorbars
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";
		unlink $columnsplot;

		my $rowsplot = $hafile;
		$rowsplot =~ s#\.txt$#-rows.plot#;
		open(HAFILE, $hafile) or die "open $hafile: $!\n";
		open(PLOT, ">$rowsplot") or die "open $rowsplot: $!\n";
		$halineno = 0;
		while (<HAFILE>) {
			my ($min, $width) = (split)[7,5];
			my $max = $min + $width;
			my $mid = ($min + $max) / 2;
			my $delta = $mid - $min;
			print PLOT "$halineno\t$mid\t$delta\n";
			$halineno++;
		}
		close(PLOT) or die "close $rowsplot: $!\n";
		close(HAFILE) or die "close $hafile: $!\n";

		my $rowspng = $hafile;
		$rowspng =~ s#\.txt$#-rows.png#;
		open(GNUPLOT, "| gnuplot") or die "open gnuplot: $!\n";
		print GNUPLOT <<EOM;
set key off
set style fill solid 1.0 noborder
set terminal png transparent small size 640,256
set output "$rowspng"

set xtics rotate
set ylabel "Border Min/Max Row"

set xlabel "Frame Number"
set format x
plot "$rowsplot" with yerrorbars
EOM
		close(GNUPLOT) or die "close gnuplot: $!\n";
		unlink $rowsplot;

		return ($blankpng, $greypng, $columnspng, $rowspng);
	}

	my $hafile = "";
	foreach my $testfile qw(HistogramAnalyzer-pgm.txt
			HistogramAnalyzer-yuv.txt) {
		if (-f $testfile) {
			$hafile = $testfile;
			last;
		}
	}
	return "" if !$hafile;

	my @histographs = gnuplot_histogramanalyzer($hafile);
	my @output;
	if (@histographs) {
		push @output, <<EOM;

<h2>HistogramAnalyzer</h2>

EOM
		my $first = 1;
		foreach my $histograph (@histographs) {
			if (-f $histograph) {
				if (!$first) {
					push @output, <<EOM;
<br />
EOM
				}
				push @output, <<EOM;
<img src="$histograph"
	title="$histograph" />
EOM
				$first = 0;
			}
		}
	}
	@output;
}

sub footer()
{
	return <<EOM;

</body>

</html>
EOM
}

sub analyze($)
{
	my ($debugdir) = @_;

	chdir($debugdir) or die "chdir $debugdir: $!\n";
	my @output;
	push @output, header($debugdir);
	push @output, templatefinder();
	push @output, templatematcher();
	push @output, histogramanalyzer();
	push @output, footer();

	my $output = "index.html";
	open(OUTPUT, ">$output") or die "open $output: $!\n";
	print OUTPUT @output or die "print $output: $!\n";
	close(OUTPUT) or die "close $output: $!\n";
}

if (!@ARGV) {
	my $basename = basename($0);
	print <<EOM;
Usage: $0 <debugdir> [debugdir...]
Generates an index.html file with graphical report on mythcommflag analysis
Requires ImageMagick and Gnuplot

Example: $basename /media/myth/recordedtv/1051_20061214210000-debug
EOM
}

umask(022);
my $cwd = getcwd();
foreach my $debugdir (@ARGV) {
	print "$debugdir\n";
	analyze($debugdir);
	chdir($cwd) or die "chdir $cwd: $!\n";
}
